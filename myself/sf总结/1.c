1.杨辉三角：
构建时：俩个for循环：  核心a[i][j]=a[i-1][j]+a[i-1][j-1];
输出时：俩个for，加if(不打印0 )
数组初始化：
(1)初始化最左边一列，适用阶数少，
(2)初始化塔尖，使用阶数多，缺点浪费数组前两行俩列

2.比较俩个数字最大值
默认最大值是第一个
实现：
(1)if
(2)三目运算

3.连乘连加
定义一个sum;
sum=sum+*  ；

4.让一个数组中的元素逆序输出
(数值判断)类似于俩俩握手，你和我握手，也就是我和你握手，只要执行一次就可以，
核心:
(1).用交换（用第三方变量）
t=a[i];
a[i]=a[n-i-1];
a[n-i-1]=t;
(2).判断条件：小于元素个数的一半(n/2)

(地址判断)
void reverse(int *p, int n)
{
	int temp;
	int *q = p+n-1;//q指向数组中的最后一个元素
	while(p < q)
	{
		temp = *p;
		*p = *q;
		*q = temp;
		p++;
		q--;
	}		
				

5.打印金字塔i(找规律)
个数不一，空白和*各自的规律
由特殊到一般
* 1 3 5 7 9
正：j<2n+1  k<n-1-i
反：j=2n-1-i-k k<=i

6.字符串拷贝(strcpy)
while(*p++=*q++);
while(a[j++] = b[i++]);

7.判断某个字母出现频率（指针）
int get_hcount(char *q)
{
	int count=0;
	while(*q!='\0')
	{
		if(*q=='h')
		{
			count++;
		}
		q++;
	}
	return count;
}

8.判断俩个字符串大小
默认相等得0；
循环判断条件：while(p[i]!='\0' ||  q[i]!='\0')
              while(*p！='\0' ||  *q!='\0')
				  
9.求二进制下 某个数字 1的个数	
()%   /
()按位与 and 右移一位 	  
			  
			  
			  
			  