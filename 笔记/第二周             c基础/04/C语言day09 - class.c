//复习
结构体 : 自定义的一个数据类型 

struct student
{
	char name[20];
	int age;
	int score;
};//一定要有;号


struct student s;
s.name = "zhangsan";//错误

strcpy(s.name,"zhangsan");

结构体变量访问成员变量用 . 

struct student *p = &s;

p->age = 10;

结构体指针访问成员变量用 ->

//结构体在参数传递的过程中我们通常采用 地址传递 节省空间（任何类型的指针变量都占4个字节）

struct student s[2] = {{"zhangsan",12,33},{"lisi",11,22}};

s//struct student *  指针 

////////////////////////////////////////////////

内存管理 

静态分配和动态分配

静态分配：编译的时候确定大小

动态分配: 运行时确定大小 


动态内存分配申请的空间 在堆区开辟 
char *p =  malloc(100);//100代表申请内存空间的大小100字节
struct student *p =  malloc(100*sizeof(struct student));//100代表申请内存空间的大小100字节


void *malloc(size_t size); //malloc返回值是void * 无类型指针，，代表申请空间的首地址

void * 可以赋值给任意类型的指针变量

char *p = "hello";//将“hello”字符串的首地址保存到指针变量p里
char q[] = "hello";
char z[100] = "hello";

sizeof(p) ? 4
sizeof(q) ? 6
sizeof(z) ? 100

strlen(p) ? 5
strlen(q) ? 5
strlen(z) ? 5
strlen("hello") ? 5

/////////////////////////////////////////////////////////

a = 60 
b = 13
c = 0
		
a = 60	 0011 1100

b = 13   0000 1101
	
a & b //1代表真，0代表假，同真为真，一假即假

0011 1100	
0000 1101
0000 1100 //12


a | b //1代表真，0代表假，同假为假，一真即真

0011 1100	
0000 1101
0011 1101 //61	
	
a ^ b //1代表真，0代表假，相同为假，不同为真
0011 1100	
0000 1101	
0011 0001 //49	

a << 3 

0011 1100 //左移之后  0011 1100 000 ，左移3位相当于原来的基础上 乘以 60 * 2的3次幂

a >> 3

0011 1100 //右移之后 0011 1（删除低3位），右移3位，相当于原来的基础上 除以2的3次幂   60 / 2的3次幂

	

	
	
	a & b  ##0000 1100 ##相当于&&，一假即假，同真为真 1代表真 0 代表假  等于12
	
	a | b  ##0011 1101 ##相当于||， 一真即真，同假为假 1代表真  0代表假  等于61
	
	a ^ b  ##0011 0001 ##异或 相同为假 不同为真 1代表真，0代表假  等于49
	
	a << 3 ##0001 1110 0000 ##整体向左移动三位，空出的后三位用0填充，相当于后面加3个0  ，如果左移动n位 相当于 a * 2的n次幂
	
	a >> 3 ##0000 0111 ##整体向右移动三位，相当于将后三位删除，相当于 a / 2 的 3次幂  60 / 8  == 7，如果右移动n位，相当于a / 2的n次幂
	
	~a     ##1100 0011 ##所有位取反，1变0，0变1  等于-61
	
	
	
unsigned int a;//无符号整形变量a
int a;//有符号的整形变量a

对于有符号的变量最高位是符号位

最高位为0 代表正数

最高位为1 代表负数

1 + -1 == 0

正数 原码 == 反码 == 补码 

负数 原码 反码（原码的符号位不变，其它位取反） 补码(反码+1)

 1
 
 
原码 0000 0000 0000 0000 0000 0000 0000 0001

反码 0000 0000 0000 0000 0000 0000 0000 0001

补码 0000 0000 0000 0000 0000 0000 0000 0001
 
 -1
 
原码 1000 0000 0000 0000 0000 0000 0000 0001
 
反码 1111 1111 1111 1111 1111 1111 1111 1110

补码 1111 1111 1111 1111 1111 1111 1111 1111

#根据补码求原码
	（1）将补码符号位不变，其它位取反
	 1000 0000 0000 0000 0000 0000 0000 0000
	（2） + 1
	 1000 0000 0000 0000 0000 0000 0000 0001
	


计算机在运算的时候用的 补码计算 

int a = 60;

补码 0000 0000 0000 0000 0000 0000 0011 1100

~a//所有位（包括符号位）1变为0,0变为1 


~a补码 1111 1111 1111 1111 1111 1111 1100 0011
	 
///根据补码求原码

	（1）符号位不变，其它位取反 
	
	   1000 0000 0000 0000 0000 0000 0011 1100
	   
	（2）+1 //得到~a的原码
	
	   1000 0000 0000 0000 0000 0000 0011 1101 -61
		
////////////////////////////////////////////////

###练习：求一个int a = 10类型数据 求二进制位1 的个数


/////方法一

#include <stdio.h>

int main(int argc, const char *argv[])
{
	int a;
	int i;
	int count = 0;
	scanf("%d",&a);
	//任何数与１进行＆运算　a & 1
	//10 1010//如果这个数的最低位为１ 结果就是１　真
	// 1 0001//如果这个数的最地位为０ 结果就是0   假
	// 如果一个数与１进行&运算如果得1 说明这个数的最低位是1
	// 如果一个数与１进行&运算如果得0 说明这个数的最低位是0
	//a 10  int 32位
	for(i = 0; i < 32; i++)
	{
		if(a & 1)//为真，说明a的最后一位是１
		{
			count++;
		}
		a >>= 1;//等价与 a = a >> 1;
	}
	printf("count is %d\n",count);
	

	return 0;
}
////////////////////////////////////

#include <stdio.h>

int main(int argc, const char *argv[])
{
	int num,i;
	int count = 0;
	printf("请您输入一个数:\n");
	scanf("%d",&num);
	while(num != 0)
	{
		if(num % 2 == 1)//先%除
		{
			count++;
		}
 		num /= 2;//再除
	}
	printf("count is %d\n",count);
}

优先级： 
括号成员第一
全体单目第二
乘除余三、加减四
移位五、关系六
。。。
按位与、异或、按位或 八九十  


	